تمرین اول طراحی شی گرایی

گام اول : افزودن دو قابلیت جدید
=======

تغییرات مربوط به روش جدید ارسال پیام
| عضو | کلاس تغییر یافته | توضیحات |
|------------------------|-----------|----------|
|نجیبی| افزودن کلاس SmsSender.java |ایجاد کلاس جدید SmsSender و متد sendSmsMessage(String to, String message) برای فعال‌سازی ارسال تاییدیه از طریق پیامک |
|نجیبی| ReservationService | افزودن یک case جدید (case sms :) به ساختار switch برای تصمیم‌گیری و فراخوانی متد جدید smsSender.sendSmsMessage(). |



تغییرات مربوط به روش جدید پرداخت
| عضو | کلاس تغییر یافته | توضیحات |
|------------------------|-----------|----------|
|انوری|PaymentProcessor | افزودن متد عمومی onSitePayment(double amount) برای پیاده‌سازی مکانیزم پرداخت حضوری در سیستم. |
| انوری |ReservationService| افزودن یک case جدید (case ONSITE:) به ساختار switch در متد makeReservation برای فراخوانی متد جدید paymentProcessor.onSitePayment() |

گام دوم : تحلیل اصول شی‌گرایی
=======

| اصل |   | کلاس | علت برقراری / نقض |
|----------|-----------|--------|---------------------------|
| **SRP** | مورد برقراری | PaymentMethods | فقط لیست انواع روش پرداخت را تعریف می‌کند که یعنی در حال انجام یک مسئولیت است.
|  | مورد نقض | ReservationService | این کلاس چندین مسئولیت را با هم انجام می‌دهد از جمله : مدیریت و پردازش رزرو، مدیریت و انجام پرداخت، محاسبه و نمایش جزئیات رزرو و ... . تغییر در هرکدام از این حوزه‌ها مستلزم تغییر در این کلاس می‌شود. بنابراین این مورد را نقض می‌کند.
| **OCP** | مورد برقراری | Room |این کلاس قابل گسترش از طریق ارث‌بری است بدون نیاز به تغییر کد Room مانند کلاس LuxuryRoom که از این کلاس ارث‌بری کرده است.
|  | مورد نقض | PaymentProcessor | این کلاس چندین روش پرداخت دارد که اگر بخواهد روش دیگری به آن اضافه شود، باید همین فایل تغییر کند. بنابراین این مورد را نقض می‌کند.
| **LSP** | مورد برقراری | Room | زیرکلاس می‌تواند قیمت را افزایش بدهد یا ویژگی جدید اضافه کند و مشکلی ایجاد نشود پس رابطه is a در آن برقرار است.
|  | مورد نقض 1 | ReservationService | اگر زیرکلاسی بخواهد از این کلاس ارث‌بری کند یا تغییری در خود ایجاد کند، باید رفتار والد را کم یا زیاد کند که این عمل باعث نقض LSP می‌شود.
|  | مورد نقض 2 | PaymentProcessor | اگر زیرکلاسی بخواهد از این کلاس ارث‌بری کند یا تغییری در خود ایجاد کند، باید همه‌ی رفتار های والد خود را حفظ کند بنابراین این مورد نقض می‌شود.
| **ISP** | مورد برقراری |  | هیچ کلاسی وجود ندارد که این اصل برای آن برقرار باشد.
|  | مورد نقض | PaymentProcessor |این کلاس یک اینترفیس بزرگ است که اگر بخواهیم یک نوع پرداخت بسازیم، نیاز به متدهای اضافی و بی‌معنی داریم. بنابراین این مورد نقض می‌شود.
| **DIP** | مورد برقراری |  | هیچ کلاسی وجود ندارد که این اصل برای آن برقرار باشد.
|  | مورد نقض | ReservationService | این کلاس مستقیم به جزئیات زیرکلاس هایش وابسته است اما اگر تغییری در هرکدام از زیرکلاس ها صورت بگیرد، باید در ReservationService هم تغییر ایجاد شود. بنابراین DIP نقض می‌شود.
| **PLK** | مورد برقراری | Customer | ارتباط غیرمستقیم با چیزی ندارد.
|  | مورد نقض | ReservationService | از زنجیره تماس‌های طولانی استفاده می‌کند، یعنی به ساختار داخلی آبجکت‌ها نفوذ کرده و با وابستگان غیرمستقیم خود تعامل می‌کند. بنابراین این مورد را نقض می‌کند.
| **CRP** | مورد برقراری | Customer | همیشه همراه مدل‌های دیگر استفاده می‌شود و چرخهٔ تغییرش با Room/Reservation هم‌راستا است.
|  | مورد نقض | ReservationService | در یک پکیج مشترک با PaymentProcessor و EmailSender قرار گرفته ولی چرخه تغییرشان مشترک نیست و همیشه باهم استفده نمی‌شوند. بنابراین وجودشان در پکیج service خلاف CRP است.


گام سوم : اصلاح موارد نقض
=======

| اصل | نقض در گام ۲ | تغییرات انجام‌شده برای رفع نقض در گام ۳ |
|------|-------------|-------------------------------------------|
| **SRP** | ReservationService چند مسئولیت داشت (پرداخت، پیام، رزرو)؛ PaymentProcessor و MessageSender نیز چندوظیفه‌ای بودند | - جدا کردن مسئولیت‌ها در چند کلاس مستقل  <br> - حذف کامل PaymentProcessor  <br> - ایجاد EmailNotifier و SmsNotifier مستقل  <br> - ReservationService فقط مسئول رزرو است |
| **OCP** | PaymentProcessor برای هر روش پرداخت جدید باید تغییر می‌کرد (if / switch) | - ایجاد interface به نام PaymentMethod <br> - ساخت کلاس‌های مستقل: PaypalPayment، CreditCardPayment، OnSitePayment <br> - حذف تمام ساختارهای شرطی پرداخت |
| **LSP** | ReservationService و PaymentProcessor رفتار قابل‌جایگزینی نداشتند | - حذف PaymentProcessor (طراحی اشتباه) <br> - final کردن ReservationService <br> - جایگزینی رفتارها با interfaceها و تزریق وابستگی |
| **ISP** | وجود interface/کلاس بزرگ مانند PaymentProcessor با چندین متد غیرمرتبط | - ساخت دو interface کوچک و تخصصی: PaymentMethod و Notifier <br> - هر کلاس فقط یک متد لازم را پیاده‌سازی می‌کند |
| **DIP** | ReservationService مستقیم به کلاس‌های concrete وابسته بود (مثل EmailSender یا PaymentProcessor) | - تزریق وابستگی از طریق سازنده (Constructor Injection) <br> - وابستگی به abstraction (PaymentMethod, Notifier) <br> - ReservationService دیگر هیچ کلاس concrete را new نمی‌کند |
| **PLK** | وجود زنجیره تماس‌های طولانی در ReservationService مانند room.getPrice().get… | - افزودن متدهای calculateTotal() و summary() در Reservation <br> - عدم دسترسی ReservationService به ساختار داخلی مدل‌ها |
| **CRP** | قرار گرفتن کلاس‌هایی با چرخه تغییر متفاوت در یک پکیج مشترک (services) | - تقسیم پروژه به پکیج‌های مجزا: payment ،notification ،reservation ،models <br> - هر پکیج فقط کلاس‌های با چرخه تغییر مشترک را نگه می‌دارد |


گام چهارم : ارزیابی
=======
| شماره | بخش مقایسه                              | قبل از SOLID                                                                                          | بعد از SOLID                                                                          |
| ----- | --------------------------------------- | ----------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- |
| **1** | اضافه‌کردن یک روش پرداخت جدید           | نیاز به تغییر PaymentProcessor، ReservationService و اضافه‌کردن if/else یا switch → نقض OCP، SRP، DIP | فقط اضافه‌کردن یک کلاس جدید مانند `CryptoPayment` بدون تغییر حتی یک خط از کدهای موجود |
| **2** | اضافه‌کردن پیام‌رسان جدید (مثل SMS)     | تغییر در MessageSender و ReservationService + اضافه‌کردن شرایط جدید → وابستگی سفت‌وسخت                | فقط ساختن یک کلاس جدید مثل `SmsNotifier` بدون تغییر اجرای قبلی                        |
| **3** | وضعیت ReservationService                | در هر تغییر باید ویرایش شود و منطق‌های اضافی در آن جمع می‌شود                                         | بدون تغییر باقی می‌ماند چون فقط با Interfaceها کار می‌کند                             |
| **4** | استفاده از if/else برای قابلیت‌های جدید | وجود if/else و switch برای مدیریت انواع پرداخت و پیام                                                 | هیچ if/else موردنیاز نیست؛ هر چیز جدید یک کلاس جدید است                               |
| **5** | نگهداری و توسعه‌پذیری کد                | وابستگی زیاد، تغییرات دومینویی، ریسک بالا                                                             | نگهداری آسان، توسعه‌پذیری نامحدود، ساختار پاک و پایدار                                |




گام پنجم : نتیجه گیری
======= 
برنامه راحت‌تر نگه‌داری شد  
اضافه کردن قابلیت جدید بدون خراب کردن کدهای قبلی ممکن شود  
خوانایی کد بالا برود   
وابستگی بین کلاس‌ها کم شود   
خطاها کمتر و پیدا کردنشان ساده‌تر شود   
به همین دلیل نسخهٔ جدید بسیار حرفه‌ای‌تر و مناسب‌تر برای توسعه است.  
